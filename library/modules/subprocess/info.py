import subprocess as sbp

# Если открыто несколько экземпляров какого-либо приложения,
# то каждый из этих экземпляров является отдельным процессом
# одной и той же программы. Например если открыть одновременно
# несколько окон в своём браузере, то все они будут 
# представлять собой разные процессы одной программы 
# браузера.

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::

sbp.getoutput('date') # 'Сб дек  2 12:27:23 +03 2017'
# запустить программу date и получаем результат её работы

sbp.check_output(['date', '-u'])
# b'\xd0\xa1\xd0\xb1 \xd0\xb4\xd0\xb5\xd0\xba  2 09:33:51 UTC 2017\n'
# принимает список команд и аргументов. По умолчанию
# он возвращает объект типа bytes , а не строки и не 
# использует оболочку

sbp.getstatusoutput('date') # (0, 'Сб дек  2 12:35:47 +03 2017')
# получение статуса выхода программы

a = sbp.call('date') # 0
a = sbp.call('date -u', shell=True) # доп. арг. трубуют вызова оболочки
a = sbp.call(['date', '-u']) # не требует вызова оболочки
# если нужен не результат работы программы, а только код
# 0 является статусом символизируюшем об успехе


ex = sbp.Popen(args, bufsize, executable, stdin, stdout, stderr, 
	preexec_fn, close_fds, shell, cwd, env, universal_newlines, 
	startupinfo, creationflags)
# запуск внешних программ из сценария Python
ex.poll()
# проверка завершена ли работа программы, если нет возвращает 
# None, если да то он возвращает целочисленый код программы
# если 0, то программа завершилась без ошибкой.
ex.wait()
# ожидает пока программа завершится, прежде чем продолжить
# работу программы, как только программа завершилась, 
# возвращает значение 0
sbp.Popen(['/usr/bin/subl', 'info.py'])
# запускает программу и передаёт файл в качестве аргумента
sbp.Popen(['start', 'hello.txt'], shell=True)
# автоматический запуск приложения, отвечающего за 
# запуск файлов с таким расширением, в Windows start,
# в Linux see, в OSX open. В Windows также обязательно
# передать второй аргумент shell=True