Threading :::::::::::::::::::::::::::::::::::::::::::::::::::::

# Этот модуль создает более высокоуровневые интерфейсы потоков 
# поверх модуля _thread нижнего уровня.
# Чтобы понять, что такое многопоточность приведём такую 
# аналогию. Предположим, что процесс выполнения программы 
# уподобляется перемещению вашего пальца по строкам кода - 
# либо последовательно, от одной строки кода к следующей, либо
# в соответствии с 	управляющими инструкциями, совершая скачки
# через строки кода. Выполнением однопоточных программ может
# выполнять только один "палец". Однако у многопоточных программ
# таких "пальцев" может быть несколько.

# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# Документация на руском:
# https://www.ibm.com/developerworks/ru/library/l-python_part_9/index.html
# https://habrahabr.ru/post/149420/

# Документация на английском:
# https://docs.python.org/3/library/threading.html

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

import threading as th

# Thread-Local Data ::::::::::::::::::::::::::::::::::::::::::::
class threading.local
# Локальными данными по потоку являются данные, значения которых 
# зависят от потока. Чтобы управлять потоковыми локальными 
# данными, просто создайте экземпляр и сохраните атрибуты

mydata = threading.local()
mydata.x = 1
# значения экземпляра будут разными для отдельных потоков.




# threading methods :::::::::::::::::::::::::::::::::::::::::::::
th.active_count()
# возвращает количество активных в настоящий момент экземпляров 
# класса Thread. Фактически это len(threading.enumerate())

th.current_thread()
# возвращает текущий объект-поток, т.е. соответствующий потоку 
# управления, который вызвал эту функцию.

th.enumerate()
# возвращает список активных потоков. Список включает в себя 
# демонические потоки, фиктивные объекты потока, созданные 
# current_thread(), и основной поток. Он исключает завершенные 
# потоки и потоки, которые еще не запущены.

th.main_thread()
# вернёт главный объект Thread. В обычных условиях основной 
# поток - это поток, из которого был запущен интерпретатор 
# Python.

th.settrace(func)
# задаёт функцию трассировки для всех потоков, запущенных из 
# модуля потоковой передачи. Функция func будет передана 
# sys.settrace() для каждого потока, прежде чем вызывается 
# метод run()

th.setprofile(func)
# задаёт профиль func для всех потоков, запущенных из модуля 
# потоковой передачи. Функция func будет передана в 
# sys.setprofile() для каждого потока, до вызова метода run()

th.stack_size([size])
# вернёт размер стека вновь созданных потоков. Необязательный 
# аргумент размера определяет размер стека, который будет 
# использоваться для созданных впоследствии потоков, и должен 
# быть либо 0 (использует платформу или настроен по умолчанию), 
# либо положительное целое значение не менее 32768 (32 KiB). 
# Если размер не указан, используется 0. 
# Если изменение размера стека потоков не поддерживается, возникает 
# RuntimeError. Если указанный размер стека недействителен, 
# создается ValueError, и размер стека не изменяется.

th.TIMEOUT_MAX
# максимальное значение, разрешенное для параметра таймаута 
# блокирующих функций (Lock.acquire(), RLock.acquire(), 
# Condition.wait() и т.д.). Указание тайм-аута, большего, чем 
# это значение, вызовет OverflowError



# Thread Objects :::::::::::::::::::::::::::::::::::::::::::::::
class threading.Thread(group=None, target=None, name=None, 
	args=(), kwargs={}, *, daemon=None)
# Класс Thread представляет собой действие, которое выполняются 
# в отдельном потоке управления. Существует два способа указания 
# активности: путем передачи вызываемого объекта конструктору 
# или переопределения метода run() в подклассе. Никакие другие 
# методы (кроме конструктора) не должны быть переопределены в 
# подклассе. Другими словами, переопределяйте только методы
# __init __() и run() этого класса.
	
	group
	# должен быть None; зарезервировано для будущего расширения 
	# при реализации класса ThreadGroup

	target
	# вызываемый объект, вызываемый методом run(). 
	# По умолчанию - None, то есть ничего не вызывается.

	name
	# это имя потока. По умолчанию уникальное имя построено из 
	# формы «Thread-N», где N - небольшое десятичное число.

	args
	# является кортежем аргументов для вызываемого объекта target. 
	# По умолчанию ()

	kwargs
	# является словарём аргументов для вызываемого объекта target. 
	# По умолчанию {}

	daemon
	# если не None, daemon явно задает, является ли поток 
	# демоническим. Если None (по умолчанию), свойство daemonic 
	# наследуется от текущего потока

th_obj.name
# вернёт имя потока

th_obj.ident
# возвращает идентификатор потока или None, если поток не запущен.

th_obj.start()
# запуск патока

th_obj.run()
# после запуска потока, автоматически запускается метод run()
# поэтому можно реализовать требуемые действия при запуске
# потока (обычно перекрывается разработчиком в подклассе)

th_obj.join(timeout=None)
# Приостановка до завершения запущенного потока; блокировка,
# если не задан параметр timeout (в секундах)

th_obj.getName()
# возвращает имя потока

th_obj.setName(name)
# присваивает потоку имя name

th_obj.get_ident()
# возвращает «идентификатор» текущего потока. Это отличное от 
# нуля целое число.

th_obj.is_alive()
# возвращает истину, если поток работает (метод run() уже 
# вызван)

th_obj.daemon = True
# обозначает поток как выполняющий функции демона, необходимо 
# применять оператор присврения прежде чем запустить поток.
# Чтобы проверить выполняет ли поток функции демона достаточно
# лишь проверить значение данного свойства объекта.
# Новый дочерний поток наследует свой флаr, обозначающий ero в 
# качестве демона, от родительскою потока. 





# Lock Objects ::::::::::::::::::::::::::::::::::::::::::::::::::
class threading.Lock
# Конструктор для примитивного объекта блокировки (такая же 
# блокировка как и в методе thread) - изначально созданные объекты
# с помощью этого конструктора не пренадлежат какомуто потоку, это
# просто объект блокировки, который по умолчанию создаётся в 
# незаблокированном состоянии.

lk.acquire(blocking=True, timeout=-1)
# делает запрос на запирание замка. Если параметр blocking не 
# указан или является истиной, то поток будет ожидать 
# освобождения замка. Если параметр не был задан, метод не 
# возвратит значения. Если blocking был задан и истинен, метод 
# возвратит True (после успешного овладения замком). Если 
# блокировка не требуется (т.е. задан blocking=False), метод 
# вернет True, если замок не был заперт и им успешно овладел 
# данный поток. В противном случае будет возвращено False

lk.release()
# запрос на отпирание замка

lk.locked()
# возвращает текущее состояние замка (True – заперт, 
# False – открыт)




# RLock Objects :::::::::::::::::::::::::::::::::::::::::::::::::
class threading.RLock
# Этот конструктор создаёт реентерабельный объект блокировки,
# который может в отдельном потоке (повторно) захватывать уже
# захваченную блокировку (это рекурсивная блокировка)

rl.acquire(blocking=True, timeout=-1)
# делает запрос на запирание замка. Если параметр blocking не 
# указан или является истиной, то поток будет ожидать 
# освобождения замка. Если параметр не был задан, метод не 
# возвратит значения. Если blocking был задан и истинен, метод 
# возвратит True (после успешного овладения замком). Если 
# блокировка не требуется (т.е. задан blocking=False), метод 
# вернет True, если замок не был заперт и им успешно овладел 
# данный поток. В противном случае будет возвращено False

rl.release()
# запрос на отпирание замка



# Condition Objects :::::::::::::::::::::::::::::::::::::::::::::
class threading.Condition(lock=None)
# Объект условной переменной вынуждает один поток ожидать, пока 
# определен­ное условие не будет выполнено другим потоком. Таким 
# условием может быть изменение состояния или задание
# определенного значения данных

	lock
	# если аргумент блокировки задан, а не None, он должен быть 
	# объектом Lock или RLock, и он используется в качестве 
	# основной блокировки. В противном случае создается новый 
	# объект RLock и используется в качестве основной блокировки.

con.acquire(*args)
# приобретает базовый замок. Этот метод вызывает соответствующий 
# метод на основе блокировки; возвращаемое значение - это то, что 
# возвращает этот метод.

con.release()
# отпускает базовую блокировку. Этот метод вызывает соответствующий 
# метод на основе блокировки; нет возвращаемого значения.

con.wait(timeout=None)
# подождать, пока не будет уведомлен или пока не произойдет 
# тайм-аут. Если вызывающий поток не получил блокировку, при 
# вызове этого метода, возникает RuntimeError.

con.wait_for(predicate, timeout=None)
# подождать, пока условие примет значение true. предикат должен быть 
# вызываемым, результат которого будет интерпретироваться как 
# логическое значение. Может быть предоставлен тайм-аут, дающий 
# максимальное время ожидания.

con.notify(n=1)
# по умолчанию пробуждает один поток, ожидающий этого, если он 
# есть. Если вызывающий поток не получил блокировку при вызове 
# этого метода, возникает RuntimeError.

con.notify_all()
# пробуждает все потоки, ожидающие этого состояния. Этот метод 
# действует как notify(), но пробуждает все ожидающие потоки 
# вместо одного. Если вызывающий поток не получил блокировку при 
# вызове этого метода, возникает RuntimeError.




# Semaphore Objects :::::::::::::::::::::::::::::::::::::::::::::
class threading.Semaphore(value=1)
# Семафор управляет внутренним счетчиком, который уменьшается 
# c каждым вызовом receive() и увеличивается каждым вызовом 
# release(). Счетчик никогда не может опускаться ниже нуля; когда 
# функция gets() обнаруживает, что она равна нулю, она блокируется, 
# ожидая, пока какой-либо другой поток вызовет release().

sem.acquire(blocking=True, timeout=None)
# при вызове без аргументов: 
	# если внутренний счетчик больше нуля при входе, уменьшит 
	# его на единицу и немедленно вернёт истину. 

	# если внутренний счетчик равен нулю при входе, заблокирует 
	# до пробуждения вызовом release(). Раз проснувшись (и счетчик 
	# больше 0), уменьшит счетчик на 1 и верните true. Точно один 
	# поток будет разбужен каждым вызовом release(). На порядок, 
	# в котором пробуждаются потоки, не следует полагаться. 
	# При вызове с блокировкой установлено значение false, не блокируйте. 
# Если вызов без аргумента блокируется, немедленно вернёт false; в 
# противном случае сделает то же самое, что и при вызове без 
# аргументов, и верните true. При вызове с таймаутом, отличным от 
# None, он будет блокироваться в течение не более секунд. 
# Если получение не завершено успешно в этом интервале, вернёт false. 
# Верно true.

sem.release()
# отпускает семафор, увеличив внутренний счетчик на единицу. Когда 
# он был равен нулю при входе, а другой поток ожидает, что он снова 
# станет больше нуля, пробуждает этот поток.

class threading.BoundedSemaphore(value=1)
# Класс реализует объекты с ограниченным семафором. Ограниченный 
# семафор проверяет, чтобы его текущее значение не превышало его 
# начального значения, иначе будет вызван ValueError. В большинстве 
# ситуаций семафоры используются для защиты ресурсов с 
# ограниченными возможностями. Если семафор выпущен слишком много 
# раз, это признак ошибки. Значение по умолчанию равно 1.




# Event Objects ::::::::::::::::::::::::::::::::::::::::::::::::::::
class threading.Event
# Это один из простейших механизмов связи между потоками: один поток 
# сигнализирует о событии, а другие потоки ожидают его. Объект 
# события управляет внутренним флагом, который может быть установлен 
# в true с помощью метода set() и сбрасывается на false с помощью 
# метода clear(). Метод wait() блокирует, пока флаг не будет истинным.
# Обобщенная версия условных переменных, которая позволяет обеспечить
# ожидание некоторого события любым количеством потоков, так что после 
# об­наружения этого события происходит активизация всех потоков

ev.is_set()
# возвращает true, если и только если внутренний флаг имеет значение 
# true

ev.set()
# установливает для внутреннего флага значение true. Все потоки, 
# ожидающие его появления, пробуждаются. Потоки, которые вызывают 
# wait(), когда флаг является истинным, не будут блокироваться вообще.

ev.clear()
# сбросывает внутренний флаг на false. Впоследствии потоки, вызывающие 
# wait(), будут блокироваться до тех пор, пока не будет вызван вызов 
# set(), чтобы снова установить внутренний флаг.

ev.wait(timeout=None)
# блокировать, пока внутренний флаг не будет истинным. Если внутренний 
# флаг является истинным при входе, немедленно возвращает. В противном 
# случае заблокирует, пока другой поток не вызовет set(), чтобы 
# установить флаг в true или до тех пор, пока не произойдет 
# дополнительный тайм-аут.





# Barrier Objects ::::::::::::::::::::::::::::::::::::::::::::::::::::
class threading.Barrier(parties, action=None, timeout=None)
# Создает барьер, которого должно достичь определенное количество 
# потоков, прежде чем всем этим потокам будет разрешено продолжить 
# работу
# Этот класс обеспечивает простой примитив синхронизации для потоков, 
# которым нужно ждать друг друга. Каждый из потоков пытается передать 
# барьер, вызвав метод wait() и заблокирует, пока все потоки не вызовут 
# вызовы wait(). В этот момент потоки освобождаются одновременно.
	parties
	# задаёт кол-во потоков которые должны достигнуть барьера
	action
	# задёт действия которые будут вызваны одним из потоков после
	# их освобождения
	timeout
	# задаёт время работы барьера. Сработает в том случае если wait()
	# не задал свой timeout

bar.wait(timeout=None)
# Поток запускает wait() если хочет пройти через барьер. Когда все 
# потоки, связанные с барьером, вызвали эту функцию, все они проходят 
# одновременно. Если в конструкторе барьера установлен timeout и в 
# wait() установлен timeout. То сработает тот таймер который в wait().

bar.reset()
# вернёт барьер в состояние по умолчанию, пустое. Любые потоки, 
# ожидающие его, получат исключение BrokenBarrierError. Обратите 
# внимание, что использование этой функции может потребовать некоторой 
# внешней синхронизации, если есть другие потоки, состояние которых 
# неизвестно. Если барьер сломан, может быть лучше просто оставить 
# его и создать новый.

bar.abort()
# помещает барьер в разбитое состояние. Это приводит к тому, что 
# любые активные или будущие вызовы wait() выкидывают BrokenBarrierError. 
# Используйте это, например, если необходимо выполнить одно из 
# требований, чтобы избежать блокировки приложения

bar.parties
# количество потоков, необходимых для прохождения барьера

bar.n_waiting
# число потоков, которые в настоящее время ждут в барьере

bar.broken
# True, если барьер находится в сломанном состоянии.

exception threading.BrokenBarrierError
# это исключение, подкласс RuntimeError, возникает, когда объект 
# Barrier сбрасывается или прерывается.



# Timer objects ::::::::::::::::::::::::::::::::::::::::::::::::::::::
class threading.Timer(interval, function, args=None, kwargs=None)
# Создаёт поток по таймеру, который будет запускать функцию с 
# аргументами args и ключевыми аргументами kwargs, после того, как 
# пройдут интервал времени. Если args - None (по умолчанию), тогда 
# будет использоваться пустой список. Если kwargs - None (по умолчанию),
# то будет использоваться пустой dict.

tm.cancel()
# Остановить таймер и отменить действие выполняемые таймером. Это 
# будет работать, только если таймер все еще находится на стадии 
# ожидания.
