socket ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# Этот модуль обеспечивает доступ к интерфейсу сокетов BSD. Он 
# доступен для всех современных Unix-систем, Windows, MacOS и, 
# возможно, для дополнительных платформ.

# документация на английском:
# https://docs.python.org/3/library/socket.html

# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

import socket as s

# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

s.socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None)
# предназначена для создания объекта сокета. В качестве параметра
# famile может применяться AF_UNIX (семейство сокетов для локального
# взаимодействия), AF_INET (семейство сокетов для web взаимодействия). 
# Параметр type может представлять собой SOCK_STREAM (TCP) или 
# SOCK_DGRAM (UDP) 

s.socketpair([family[, type[, proto]]])
# создание пары объектов сокета на основе указанных параметров: 
# семейство адресов, тип сокета и тип протокола (необязательно)

s.create_connection(address[, timeout[, source_address]])
# Вспомогательная функция, которая принимает пару параметров 
# определения адреса (хост, порт) и возвращает объект socket

s.fromfd(fd, family, type, proto=0)
# Создание объекта сокета на основе дескриптора открытого файла

s.fromshare(data)
# Выполняет инициализацию сокета из данных, полученных из метода 
# socket.share(). Предполагается, что сокет находится в режиме 
# блокировки.

s.SocketType
# Это объект типа Python, который представляет тип объекта сокета. 
# Это то же самое, что и type(socket(...)).

s.getaddrinfo(host, port, family=0, type=0, proto=0, flags=0)
# Получает информацию адреса в виде последовательности 
# пятиэ­лементных кортежей

s.getfqdn([name])
# Возвращает полное доменное имя

s.gethostbyname(hostname)
# Преобразует имя хоста в его IР-адрес

s.gethostbyname_ex(hostname)
# Расширенная версия функции gethostbyname(), возвращающая имя 
# хоста, набор имен хостов псевдонимов и список IР-адресов

s.gethostname()
# Возвращает текущее имя хоста

s.gethostbyaddr(ip_address)
# Преобразует IР-адрес в информацию DNS; возвращает такой же 
# трехэлементный кортеж. что и функция gethostbyname_ex()

s.getnameinfo(sockaddr, flags)
# Принимая в качестве параметра адрес сокета, возвращает 
# двухэ­лементный кортеж (хост, порт)

s.getprotobyname(protocolname)
# Преобразует имя протокола (например, 'tcp') в числовое 
# обо­значение

s.getservbyname(servicename[, protocolname])
# Преобразует имя службы в номер порта, имя про­токола является 
# необязательным

s.getservbyport(port[, protocolname])
# # Преобразует номер порта в имя службы, имя про­токола является 
# необязательным

s.ntohl(x)
# Обеспечивает преобразование внутреннего представления целых
# чисел из формата сети в формат хоста. Преобразование 32-битных 
# положительных целых чисел из порядка сети в хост. На машинах, 
# где порядок байтов хоста совпадает с порядком сетевого байта, 
# это не-op; в противном случае он выполняет операцию байта 
# с 4 байтами.

s.ntohs(x)
# Преобразование 16-битных положительных целых чисел из порядка 
# сети в хост. На машинах, где порядок байтов хоста совпадает с 
# порядком сетевого байта, это не-op; в противном случае он 
# выполняет операцию смены в 2 байта.

s.htonl(x)
# Обеспечивает преобразование внутреннего представления 32-битных 
# целых чисел из формата хоста в формат сети

s.htons(x)
# Обеспечивает преобразование внутреннего представления 16-битных 
# целых чисел из формата хоста в формат сети

s.inet_aton(ip_string)
# Преобразует строку IР-адреса в 32-разрядный упакован­ный 
# формат (только для адресов IPv4)

s.inet_ntoa(packed_ip)
# Преобразует 32-разрядный упакован­ный формат в строку IР-адреса 
# (только для адресов IPv4)

s.inet_pton(address_family, ip_string)
# Преобразует строку IР-адреса в упакованный двоичный формат,
# (и для адресов IPv4, и для адресов IPvб)

s.inet_ntop(address_family, packed_ip)
# Преобразует упакованный двоичный формат в строку IР-адреса,
# (и для адресов IPv4, и для адресов IPvб)

s.CMSG_LEN(length)
# 

s.CMSG_SPACE(length)
#

s.getdefaulttimeout()
# Возвращает значение по умолчанию тайм-аута сокета в секун­дах 
# (число с плавающей точкой)

s.setdefaulttimeout(timeout)
# задает значение по умолчанию тайм-аута сокета в секундах 
# (число с плавающей точкой)

s.sethostname(name)
# Задайте имя хоста машины. Это приведет к вызову OSError, если у 
# вас недостаточно прав.

s.if_nameindex()
# Вернёт список информации о сетевом интерфейсе (индекс, имя). 
# OSError, если системный вызов завершается с ошибкой.

s.if_nametoindex(if_name)
# Вернёт номер индекса сетевого интерфейса, соответствующий 
# имени интерфейса. OSError, если интерфейс с данным именем не 
# существует.

s.if_indextoname(if_index)
# Вернёт имя сетевого интерфейса, соответствующее номеру индекса 
# интерфейса. OSError, если интерфейс с данным индексом не существует.



# socket objects :::::::::::::::::::::::::::::::::::::::::::::::::::::::
s = socket(..., ...)

s.accept()
# блокирует приложение до тех пор, пока не придет сообщение от клиента. 
# Функция возвращает кортеж из двух параметров – объект самого соединения 
# и адрес клиента.
# Пассивно принимает клиентский запрос на установление соединения TCP,
# находясь в состоянии ожидания до поступления запроса на установления
# (блакирующий режим)

s.bind(address)
# устанавливает привязку адреса (пары состоящей из имени хоста и номера 
# порта) к сокету

s.close()
# обеспечивает закрытие сокета

s.connect(address)
# активно инициирует соединение сервера TCP

s.connect_ex(address)
# представляет собой расширенную версию метода connect(), которая 
# предусматривает возврат сообщений о возникших проблемах в виде кодов
# ошибок, а не генерирование исключения

s.detach()
# обеспечивает закрытие сокета без закрытия дескриптора файла и 
# возвра­щает дескриптор

s.dup()
# Дублирует сокет. Созданный сокет не наследуется.

s.fileno()
# определяет дескриптор файла сокета

s.get_inheritable()
# Получить наследуемый флаг дескриптора файла сокета или дескриптора 
# сокета: 
# True, если сокет может быть унаследован в дочерних процессах, 
# False, если он не может.

s.getpeername()
# задаёт удаленный адрес, подключенный к сокету (ТСР)

s.getsockname()
# задаёт адрес текущего сокета

s.getsockopt(level, optname[, buflen])
# возвращает значение указанной опции сокета

s.gettimeout()
# определяет тайм-аут для блокирующих операций сокета

s.ioctl(control, option)
# осуществляет управление режимом сокета (только в Windows)

s.listen([backlog])
# устанавливает и запускает приёмник TCP. Параметр в методе, 
# указывает максимальное кол-во входящих запросов на установление
# запросов, которые которые могут быть приняты, прежде чем 
# сервер начнёт отклонять поступающие запросы или отказывать в 
# их выполнении

s.makefile(mode='r', buffering=None, *, encoding=None, errors=None, newline=None)
# создает объект файла, связанный с сокетом

s.recv(bufsize[, flags])
# обеспечивает получение сообщений TCP

s.recvfrom(bufsize[, flags])
# обеспечивает получение сообщений UDP

s.recvmsg(bufsize[, ancbufsize[, flags]])
# Получает нормальные данные и вспомогательные данные из сокета. 
# Аргумент ancbufsize устанавливает размер в байтах внутреннего 
# буфера, используемого для получения вспомогательных данных; 
# по умолчанию оно равно 0, что означает, что никакие вспомогательные 
# данные не будут получены. Соответствующие размеры буфера для 
# вспомогательных данных могут быть вычислены с использованием 
# CMSG_SPACE() или CMSG_LEN(), а элементы, которые не помещаются 
# в буфер, могут быть усечены или отброшены. Аргумент flags по 
# умолчанию равен 0 и имеет то же значение, что и для recv()

s.recvmsg_into(buffer[, ancbufsize[, flags]])
# обеспечивает получение сообщений TCP в указанный буфер

s.recvfrom_into(buffer[, nbytes[, flags]])
# обеспечивает получение сообщений UDP в указанный буфер

s.recv_into(buffer[, nbytes[, flags]])
#

s.send(bytes[, flags])
# обеспечивает передачу сообщения TCP

s.sendall(bytes[, flags])
# обеспечивает полную передачу сообщения TCP

s.sendto(bytes, address)
s.sendto(bytes, flags, address)
# обеспечивает передачу сообщения UDP

s.sendmsg(buffers[, ancdata[, flags[, address]]])
#

s.sendmsg_afalg([msg, ]*, op[, iv[, assoclen[, flags]]])
#

s.sendfile(file, offset=0, count=None)
#

s.set_inheritable(inheritable)
#

s.setblocking(flag)
# задает блокирующий или неблокирующий режим сокета

s.settimeout(value)
# задает тайм-аут для блокирующих операций сокета

s.setsockopt(level, optname, value: int)
s.setsockopt(level, optname, value: buffer)
s.setsockopt(level, optname, None, optlen: int)
# задает значение для какой-то конкретной опции сокета

s.shutdown(how)
# осуществляет остановку соединения

s.share(process_id)
#


# атрибуты данных :::::::::::::::::::::::::::::::::::::::::::::::

s.family
# семейство сокетов

s.type
# тип сокета

s.proto
# протокол сокета


# атрибуты модуля socket ::::::::::::::::::::::::::::::::::::::::::

AF_UNIX, AF_INET, AF_INET6, AF_NETLINK, AF_TIРC
# семейства адресов сокета, поддерживаемые языком Pythoп

SOCK_STREAM, SOCK_DGRAM
# типы сокетов (ТСР - потоковый, UDP - дейтаграммный)

has_ipv6
# логический флаг, показывающий, поддерживается ли протокол IPv6