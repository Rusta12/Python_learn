import subprocess as sbp

# Если открыто несколько экземпляров какого-либо приложения,
# то каждый из этих экземпляров является отдельным процессом
# одной и той же программы. Например если открыть одновременно
# несколько окон в своём браузере, то все они будут 
# представлять собой разные процессы одной программы 
# браузера.

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::

sbp.getoutput('date')
# запустить программу date и получаем результат её работы

sbp.check_output(['date', '-u'])
# принимает список команд и аргументов. По умолчанию
# он возвращает объект типа bytes , а не строки и не 
# использует оболочку

sbp.getstatusoutput('date')
# получение статуса выхода программы

a = sbp.call('date')
a = sbp.call('date -u', shell=True) # доп. арг. трубуют вызова оболочки
a = sbp.call(['date', '-u']) # не требует вызова оболочки
# если нужен не результат работы программы, а только код
# 0 является статусом символизируюшем об успехе


ex = sbp.Popen(args, bufsize, executable, stdin, stdout, stderr, 
	preexec_fn, close_fds, shell, cwd, env, universal_newlines, 
	startupinfo, creationflags)
# запуск внешних программ из сценария Python
ex.poll()
# проверка завершена ли работа программы, если нет возвращает 
# None, если да то он возвращает целочисленый код программы
# если 0, то программа завершилась без ошибкой.
ex.wait()
# ожидает пока программа завершится, прежде чем продолжить
# работу программы, как только программа завершилась, 
# возвращает значение 0
sbp.Popen(['/usr/bin/subl', 'info.py'])
# запускает программу и передаёт файл в качестве аргумента
sbp.Popen(['start', 'hello.txt'], shell=True)
# автоматический запуск приложения, отвечающего за 
# запуск файлов с таким расширением, в Windows start,
# в Linux see, в OSX open. В Windows также обязательно
# передать второй аргумент shell=True