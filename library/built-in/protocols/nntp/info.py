nntplib :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# Протокол, с помощью которого пользователи могут загружать поступления
# (или статьи) групп новостей или сами публиковать новые Статьи, 
# именуется NNТP (Network News Transfer Protocol - протокол передачи 
# сетевых новостей).

# документация на английском:
# https://docs.python.org/3/library/nntplib.html

# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

from nntplib import *

# NNTP ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
class NNTP(host, port=119, user=None, password=None, readermode=None, 
	usenetrc=False[, timeout])
# Вернёт новый объект NNTP, представляющий соединение с сервером NNTP, 
# запущенным на хосте host, при прослушивании порта port. Дополнительный 
# timeout может быть указан для подключения сокета. Если предоставлены 
# дополнительный user и password или если в /.netrc присутствуют 
# подходящие учетные данные, а необязательный флаг usenetrc верен, 
# команды AUTHINFO USER и AUTHINFO PASS используются для идентификации 
# и аутентификации пользователя на сервере. Если опциональный флаг 
# readermode является истинным, тогда команда mode reader 
# отправляется до того, как будет выполнена аутентификация. Режим 
# чтения иногда необходим, если вы подключаетесь к NNTP-серверу на 
# локальном компьютере и намереваетесь вызывать специальные команды, 
# например group. Если вы получите неожиданные NNTPPermanentErrors, 
# вам может потребоваться установить readermode.

# objects ::::::::::::::::::::::

nntp_version
# Целое число, представляющее версию протокола NNTP, поддерживаемого 
# сервером. На практике это должно быть 2 для серверов, рекламирующих 
# соответствие RFC 3977 и 1 для других.

nntp_implementation
# Строка, описывающая имя и версию программного обеспечения сервера NNTP 
# или None, если не объявлена ​​сервером.

quit()
# Отправляет команду QUIT и закрывает соединение.

getwelcome()
# Вернёт приветственное сообщение, отправленное сервером в ответ на 
# начальное соединение. (Это сообщение иногда содержит отказ от 
# ответственности или справочную информацию, которая может иметь 
# отношение к пользователю.)

getcapabilities()
# Вернёт словарь, (возможно, пустых) списков значений. На старых серверах, 
# которые не понимают команду CAPABILITIES, вместо этого возвращается 
# пустой словарь.

login(user=None, password=None, usenetrc=True)
# Отправляет команды AUTHINFO с именем пользователя и паролем. Если 
# пользователь и пароль равны None, а usenetrc - True, учетные данные 
# из ~/.netrc будут использоваться, если это возможно. Логин обычно 
# выполняется во время инициализации объекта NNTP, и отдельно вызов 
# этой функции не требуется. Чтобы заставить аутентификацию задерживаться, 
# вы не должны устанавливать пользователя или пароль при создании объекта 
# и должны устанавливать usenetrc в False.

starttls(ssl_context=None)
# Отправляет команду STARTTLS. Это позволит шифровать соединение NNTP. 
# Аргумент ssl_context является необязательным и должен быть объектом 
# ssl.SSLContext. Обратите внимание, что это не может быть сделано после 
# того, как информация аутентификации была передана, и аутентификация 
# происходит по умолчанию, если это возможно во время инициализации объекта 
# NNTP. См. NNTP.login() для получения информации о пресечении этого поведения.

newgroups(date, *, file=None)
# Отправляет команду NEWGROUPS. Аргументом date должен быть объект 
# datetime.date или datetime.datetime. Верните пару (response, groups), где 
# groups - это список, представляющий группы, которые являются новыми с 
# указанной даты. Если файл поставлен, то группы будут пустыми.

newnews(group, date, *, file=None)
# Отправляет команду NEWNEWS. Здесь group - это имя группы или «*», а дата 
# имеет то же значение, что и для новых group(). Вернёт пару (response, articles), 
# где articles - это список идентификаторов сообщений. 
# Эта команда часто отключается администраторами NNTP-сервера.

list(group_pattern=None, *, file=None)
# Отправляет команду LIST или LIST ACTIVE. Верните пару (response, list), где 
# list - список кортежей, представляющих все группы, доступные с этого 
# NNTP-сервера, необязательно соответствующие строке шаблона group_pattern. 
# Каждый кортеж имеет форму (group, last, first, flag), где group - это имя 
# группы, last и first - это последние и первые номера статей, а flag обычно 
# принимает одно из следующих значений:
	y: # Разрешены локальные публикации и статьи от сверстников. 
	m: # Группа модерируется, и все публикации должны быть одобрены. 
	n: # Запрещены никакие локальные публикации, только статьи из сверстников. 
	j: # Статьи из сверстников подаются в нежелательной группе. 
	x: # Нет локальных сообщений, а статьи из сверстников игнорируются. 
	= foo.bar: # вместо этого статьи помещаются в группу foo.bar.
# Если флаг имеет другое значение, статус группы новостей должен считаться 
# неизвестным. Эта команда может возвращать очень большие результаты, 
# особенно если group_pattern не указан. 
# Лучше всего кэшировать результаты офлайн, если вам действительно не нужно 
# их обновлять.

descriptions(grouppattern)
# Отправляет команду LIST NEWSGROUPS, где grouppattern - это строка 
# wildmat, как указано в RFC 3977 (она по сути такая же, как 
# подстановочные строки DOS или UNIX). Вернёт пару (response, descriptions), 
# где описания представляют собой имена групп сопоставления словаря для 
# текстовых описаний.

description(group)
# Получает описание для одной группы. Если встречается несколько групп 
# (если «группа» - настоящая строка wildmat), вернёт первое совпадение. 
# Если никакая группа не соответствует, вернёт пустую строку.

group(name)
# Позволяет указать имя группы новостей и получить кортеж 
# (rsp, ct, fst, lst, group): ответ сервера, количество статей, 
# номера первой и последней статей и имя группы. Все эти параметры 
# заданы в фор­мате (name == group)

over(message_spec, *, file=None)
# Отправляет команду OVER или команду XOVER на старых серверах. 
# message_spec может быть либо строкой, представляющей идентификатор 
# сообщения, либо (first, last) набором чисел, указывающим диапазон статей 
# в текущей группе, или кортеж (first, None), указывающий диапазон статей, 
# начиная с первого и последнего в текущей группе или None, чтобы выбрать 
# текущую статью в текущей группе.
# Вернёт пару (response, overviews). Overviews представляет собой список 
# (article_number, overview) кортежей, по одному для каждой статьи, 
# выбранной командой message_spec. Каждый overview представляет собой 
# словарь с одинаковым количеством элементов, но это число зависит от 
# сервера. Этими элементами являются либо заголовки сообщений 
# (ключ - это имя заголовка с нижним окошком), либо элементы метаданных 
# (ключ - это имя метаданных, которое добавляется к «:»). 

help(*, file=None)
# Отправляет команду HELP. Верните пару (response, list), где list - 
# список строк справки.

stat(message_spec=None)
# Отправляет команду STAT, где message_spec является либо идентификатором 
# сообщения (заключенным в '<' и '>'), либо номером статьи в текущей группе. 
# Если message_spec опущен или None, рассматривается текущая статья в 
# текущей группе. Вернёт тройку (response, number, id), где number - номер 
# статьи, а id - идентификатор сообщения.

next()
# При использовании с методом stat() перемещает указатель ста­тьи 
# на следующую статью и возвращает аналогичный кортеж

last()
# Также используется вместе с методом stat(). Перемещает указа­тель 
# статьи на последнюю статью и возвращает аналогичный кортеж

article(message_spec=None, *, file=None)
# Отправляет команду ARTICLE, где message_spec имеет то же значение, что 
# и для stat(). Вернёт кортеж (response, info), где info - это namedtuple с 
# тремя номерами атрибутов, message_id и строками (в этом порядке). 
# number - номер статьи в группе (или 0, если информация недоступна), 
# message_id идентификатор сообщения в виде строки и строит список строк 
# (без завершения строк новой строки), содержащий необработанное сообщение, 
# включая заголовки и тело.

head(message_spec=None, *, file=None)
# То же, что и article(), но отправляет команду HEAD. Возвращённые линии (
# или записанные в файл), будут содержать только заголовки сообщений, а не 
# тело.

body(message_spec=None, *, file=None)
# То же, что и в article(), но отправляет команду BODY. Возвращённые линии 
# (или записанные в файл), будут содержать только тело сообщения, а не 
# заголовки.

post(data)
# Отправляет статью, используя команду POST. Аргумент data является либо 
# файловым объектом, открытым для двоичного чтения, либо любым итерабельным 
# байтовым объектом (представляющим исходные строки статьи, подлежащей 
# публикации). Он должен представлять собой хорошо сформированную новостную 
# статью, включая требуемые заголовки. Метод post() автоматически удаляет 
# строки, начинающиеся с '.' и добавляет линию завершения.

ihave(message_id, data)
# Отправляет команду IHAVE. message_id - это идентификатор сообщения для 
# отправки на сервер (заключёного в '<' и '>'). Параметры данных и 
# возвращаемое значение те же, что и для post().

date()
# Вернёт пару (response, date). date - это объект datetime, содержащий 
# текущую дату и время сервера.

slave()
# Отправляет команду SLAVE. Вернёт ответ сервера.

set_debuglevel(level)
# Установливает уровень отладки экземпляра. Контролирует объем 
# отладочного вывода. Значение по умолчанию 0 не выводит вывод 
# отладки. Значение 1 дает умеренный объем отладочного вывода, 
# как правило, одну строку для каждого запроса. Значение 2 или выше 
# дает максимальный объем отладочного вывода, регистрируя каждую 
# отправленную и полученную линию в управляющем соединении.

xhdr(hdr, str, *, file=None)
# Отправляет команду XHDR. Аргумент hdr является ключевым словом 
# заголовка, например. 'subject'. Аргумент str должен иметь форму 
# «first-last», где первый и последний являются первым и последним 
# номерами статей для поиска. Вернёт пару (response, list), где 
# list - это список пар (id, text), где id - номер статьи (в виде строки), 
# а text - текст запрошенного заголовка для этой статьи. Если параметр 
# файла указан, то вывод команды XHDR сохраняется в файле. Если файл 
# является строкой, тогда метод откроет файл с этим именем, напишет и 
# закроет его. Если файл является файловым объектом, он начнет вызывать 
# write() на нем, чтобы сохранить строки вывода команды. Если файл 
# указан, то возвращаемый список - пустой список.

xover(start, end, *, file=None)
# Отправляет команду XOVER. start и end - это номера статей, 
# ограничивающие диапазон статей для выбора. Возвращаемое значение 
# аналогично для over(). Вместо этого рекомендуется использовать 
# функцию over(), поскольку она будет автоматически использовать 
# новую команду OVER, если она доступна.

xpath(id)
# Вернёт пару (resp, path), где path - это путь к каталогу с 
# ID id сообщения. В большинстве случаев это расширение не 
# поддерживается администраторами NNTP-сервера.


# NNTP_SSL ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
class nntplib.NNTP_SSL(host, port=563, user=None, password=None, 
	ssl_context=None, readermode=None, usenetrc=False[, timeout])
# Вернёт новый объект NNTP_SSL, представляющий зашифрованное соединение 
# с сервером NNTP, запущенным на хост host, при прослушивании порта port. 
# Объекты NNTP_SSL имеют те же методы, что и объекты NNTP. Если порт 
# опущен, используется порт 563 (NNTPS). ssl_context также является 
# необязательным и является объектом SSLContext. Все остальные параметры 
# ведут себя так же, как и для NNTP.




# exception :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

NNTPError
# это базовый класс для всех исключений, вызванных модулем nntplib. 
# Экземпляры этого класса имеют следующий атрибут
	response
	# Ответ сервера, если он доступен, как str-объект


NNTPReplyError
# Исключение, возникающее при получении от сервера неожиданного ответа

NNTPTemporaryError
# Исключение возникает при получении кода ответа в диапазоне 400-499.

NNTPPermanentError
# Исключение возникает при получении кода ответа в диапазоне 500-599.

NNTPProtocolError
# Исключение возникает при получении ответа от сервера, который не 
# начинается с цифры в диапазоне 1-5.

NNTPDataError
# Исключение возникает при возникновении некоторой ошибки в данных 
# ответа.




# utilites ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

decode_header(header_str)
#