smtplib ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# Модуль smtplib определяет объект сеанса клиента SMTP, который 
# можно использовать для отправки почты на любой Интернет-компьютер 
# с помощью SMTP или ESMTP. 

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# документация на английском:
# https://docs.python.org/3/library/smtplib.html

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

import smtplib

# SMTP Objects :::::::::::::::::::::::::::::::::::::::::::::::::::::

smtplib.LMTP()
# протокол LMTP, который очень похож на ESMTP, в значительной степени 
# основан на стандартном SMTP-клиенте. Обычно используется Unix-сокеты 
# для LMTP, поэтому наш метод connect() должен поддерживать это, а 
# также обычный сервер хоста: port.

smtplib.SMTP('smtp.gmail.com', 587)
# объект SMTP представляет соединение с почтовым SMTP-сервером и 
# располагает методами для отправки сообщений электроной почты. 
# Соеденение с сервером  по протоколу TLS.

m = smtplib.SMTP_SSL('smtp.gmail.com', 465)
# Соеденение с сервером по протоколу SSL

m.set_debuglevel(level)
# установливает выходной уровень отладки. Значение 1 или True для 
# уровня приводит к отладочным сообщениям для подключения и ко всем 
# сообщениям, отправленным и получаемым с сервера. Значение 2 для 
# уровня приводит к тому, что эти сообщения имеют временную отметку.

m.docmd(cmd, args='')
# отправляет команду cmd на сервер. Необязательный аргумент args 
# просто объединяется с командой, разделенной пробелом.

m.connect(host='localhost', port=0)
# подключиться к узлу на данном порту. По умолчанию необходимо 
# подключиться к локальному хосту на стандартном SMTP-порту (25). 
# Если имя хоста заканчивается двоеточием (':'), за которым следует 
# номер, этот суффикс будет удален, а число будет интерпретироваться 
# как номер порта для использования. Этот метод автоматически 
# вызывается конструктором, если хост указан во время создания 
# экземпляра.

m.helo(name='')
# индентифицировать себя на SMTP-сервере

m.ehlo(name='')
# индентифицировать себя на сервере ESMTP. Если первым элементом
# возвращённого кортежа является целое число 250 (код успешного
# завершения операции в SMTP), то это означает, что процедура
# приветствия оказалась успешной.

m.ehlo_or_helo_if_needed()
# этот метод вызывает ehlo()/helo(), если предыдущая команда 
# EHLO или HELO не выполняла этот сеанс. Сначала он пытается
# вызвать ESMTP EHLO.

m.has_extn(name)
# вернёт True, если имя находится в наборе внутренних 
# расширений SMTP, возвращаемых сервером, иначе False.

m.verify(address)
# проверяет правильность адреса на этом сервере с помощью 
# SMTP VRFY. Многие сайты отключают SMTP VRFY, чтобы вскрыть 
# спаммеров.

m.login(email, password, *, initial_response_ok=True)
# выполнение процедуры входа. Возвращаемое в кортеже значение
# 235 говорит о том, что процедура аутентификации была успешно
# пройдена. В случае ввода неверного пароля Python возбудит 
# исключение smtplib.SMTPAuthenticationError

m.auth(mechanism, authobject, *, initial_response_ok=True)
# указывает механизм аутентификации и обработывает запрос 
# ответа через authobject. mechanism определяет, какой 
# механизм аутентификации должен использоваться в качестве 
# аргумента для команды AUTH. Класс SMTP предоставляет 
# автообъекты для механизмов CRAM-MD5, PLAIN и LOGIN; они 
# называются SMTP.auth_cram_md5, SMTP.auth_plain и 
# SMTP.auth_login соответственно. Все они требуют, чтобы 
# свойства пользователя и пароля экземпляра SMTP были 
# установлены в соответствующие значения. 
# Код пользователя обычно не требует прямого вызова auth, но 
# вместо этого может вызывать метод login(), который будет 
# поочередно проверять каждый из указанных выше механизмов в 
# указанном порядке. auth предоставляется для облегчения 
# реализации методов аутентификации, которые (или еще не 
# поддерживаются) напрямую поддерживаются smtplib.

m.starttls(keyfile=None, certfile=None, context=None)
# если подключаться к серверу SMTP через порт 587 (т.е 
# использовать TLS-шифрование), то следующим должен быть
# вызван метод starttls(). Этот шаг активизирует шифрование
# для соеденения. Возвращаемое в кортеже значение 220, 
# означает, что сервер готов. 

m.sendmail(from_addr, to_addrs, msg, mail_options=[], rcpt_options=[])
# отправка сообщения. Возвращаемое значение метода sendmail()
# является словарь. В нем будет содержаться по одной паре 
# "ключ-значение", для каждого из получателей кому НЕ удалось
# доставить сообщение. Пустой словарь означает, что сообщение было
# доставленно всем получателям/

m.send_message(msg, from_addr=None, to_addrs=None, mail_options=[], rcpt_options=[])
# Это метод для удобного вызова sendmail() с сообщением, 
# представленными объектоми mail.message.Message.
# Аргументы имеют то же значение, что и для sendmail(), 
# за исключением того, что msg является объектом Message.

m.quit()
# отключение программы от SMTP сервера, возвращаемое значение 221 
# в кортеже, означает завершение сеанса связи.



# 