#   //////////////////////////////////////////////////////////
#   NumPy ....................................................

#	NumPy — это библиотека языка Python, добавляющая поддержку 
#	больших многомерных массивов и матриц, вместе с большой 
#	библиотекой высокоуровневых (и очень быстрых) математических 
#	функций для операций с этими массивами.

#	Основным объектом NumPy является однородный многомерный 
#	массив (в numpy называется numpy.ndarray). Это многомерный 
#	массив элементов (обычно чисел), одного типа.

#	Наиболее важные атрибуты объектов ndarray: ...............

	ndarray.ndim
	# число измерений (чаще их называют "оси") массива.

	ndarray.shape
	# размеры массива, его форма. Это кортеж натуральных чисел, 
	# показывающий длину массива по каждой оси. Для матрицы из 
	# n строк и m столбов, shape будет (n,m). Число элементов 
	# кортежа shape равно ndim.

	ndarray.size 
	# количество элементов массива. Очевидно, равно произведению 
	# всех элементов атрибута shape.

	ndarray.dtype
	# объект, описывающий тип элементов массива. Можно определить 
	# dtype, используя стандартные типы данных Python. NumPy здесь 
	# предоставляет целый букет возможностей, как встроенных, 
	# например: bool_, character, int8, int16, int32, int64, float8, 
	# float16, float32, float64, complex64, object_, так и 
	# возможность определить собственные типы данных, в том числе 
	# и составные.

	ndarray.itemsize 
	# размер каждого элемента массива в байтах.

	ndarray.data
	# буфер, содержащий фактические элементы массива. Обычно не 
	# нужно использовать этот атрибут, так как обращаться к 
	# элементам массива проще всего с помощью индексов.

#	Создание массивов .............................................

#	В NumPy существует много способов создать массив. Один из наиболее 
#	простых - создать массив из обычных списков или кортежей Python, 
#	используя функцию numpy.array() (запомните: array - функция, 
#	создающая объект типа ndarray):

	import numpy as np
	a = np.array([1, 2, 3])
	a 	# array([1, 2, 3])
	type(a) # <class 'numpy.ndarray'>

#	Функция array() трансформирует вложенные последовательности в 
#	многомерные массивы. Тип элементов массива зависит от типа элементов 
#	исходной последовательности (но можно и переопределить его в момент 
#	создания).

	b = np.array([[1.5, 2, 3], [4, 5, 6]])
	b 	# array([[ 1.5,  2. ,  3. ],
       	#		[ 4. ,  5. ,  6. ]])

#	Можно также переопределить тип в момент создания:

	b = np.array([[1.5, 2, 3], [4, 5, 6]], dtype=np.complex)
	b
	# array([[ 1.5+0.j,  2.0+0.j,  3.0+0.j],
	#        [ 4.0+0.j,  5.0+0.j,  6.0+0.j]])

#	Функция array() не единственная функция для создания массивов. 
#	Обычно элементы массива вначале неизвестны, а массив, в котором 
#	они будут храниться, уже нужен. Поэтому имеется несколько функций 
#	для того, чтобы создавать массивы с каким-то исходным содержимым 
#	(по умолчанию тип создаваемого массива — float64).

#	Функция zeros() создает массив из нулей, а функция ones() — массив 
#	из единиц. Обе функции принимают кортеж с размерами, и аргумент dtype:

	np.zeros((3, 5))
	# array([[ 0.,  0.,  0.,  0.,  0.],
	#        [ 0.,  0.,  0.,  0.,  0.],
	#        [ 0.,  0.,  0.,  0.,  0.]])

	np.ones((2, 2, 2))
	# array([[[ 1.,  1.],
	#         [ 1.,  1.]],

	#        [[ 1.,  1.],
	#         [ 1.,  1.]]])

#	Функция eye() создаёт единичную матрицу (двумерный массив)

	np.eye(5)
	# array([[ 1.,  0.,  0.,  0.,  0.],
	#        [ 0.,  1.,  0.,  0.,  0.],
	#        [ 0.,  0.,  1.,  0.,  0.],
	#        [ 0.,  0.,  0.,  1.,  0.],
	#        [ 0.,  0.,  0.,  0.,  1.]])

#	Функция empty() создает массив без его заполнения. Исходное содержимое 
#	случайно и зависит от состояния памяти на момент создания массива (то 
#	есть от того мусора, что в ней хранится):

	np.empty((3, 3))
	# array([[  6.93920488e-310,   6.93920488e-310,   6.93920149e-310],
	#        [  6.93920058e-310,   6.93920058e-310,   6.93920058e-310],
	#        [  6.93920359e-310,   0.00000000e+000,   6.93920501e-310]])

	np.empty((3, 3))
	# array([[  6.93920488e-310,   6.93920488e-310,   6.93920147e-310],
	#        [  6.93920149e-310,   6.93920146e-310,   6.93920359e-310],
	#        [  6.93920359e-310,   0.00000000e+000,   3.95252517e-322]])

#	Для создания последовательностей чисел, в NumPy имеется функция arange(), 
#	аналогичная встроенной в Python range(), только вместо списков она 
#	возвращает массивы, и принимает не только целые значения:

	np.arange(10, 30, 5) # array([10, 15, 20, 25])
	np.arange(0, 1, 0.1) 
	# array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9])

# 	Вообще, при использовании arange() с аргументами типа float, сложно быть 
#	уверенным в том, сколько элементов будет получено (из-за ограничения 
#	точности чисел с плавающей запятой). Поэтому, в таких случаях обычно 
#	лучше использовать функцию linspace(), которая вместо шага в качестве 
#	одного из аргументов принимает число, равное количеству нужных элементов:

	np.linspace(0, 2, 9)  # 9 чисел от 0 до 2 включительно
	# array([  0. ,  0.25,  0.5 ,  0.75, 1. , 1.25, 1.5 , 1.75, 2. ])
	fromfunction(): # применяет функцию ко всем комбинациям индексов

	def f1(i, j):
		return 3 * i + j

	np.fromfunction(f1, (3, 4))
	# array([[ 0.,  1.,  2.,  3.],
	#        [ 3.,  4.,  5.,  6.],
	#        [ 6.,  7.,  8.,  9.]])

	np.fromfunction(f1, (3, 3))
	# array([[ 0.,  1.,  2.],
	#        [ 3.,  4.,  5.],
	#        [ 6.,  7.,  8.]])

#	Печать массивов ........................................................

#	Если массив слишком большой, чтобы его печатать, NumPy автоматически 
#	скрывает центральную часть массива и выводит только его уголки.

	print(np.arange(0, 3000, 1)) 	# [   0    1    2 ..., 2997 2998 2999]

#	Если вам действительно нужно увидеть весь массив, используйте функцию 
#	numpy.set_printoptions:

	np.set_printoptions(threshold=np.nan)

# 	И вообще, с помощью этой функции можно настроить печать массивов 
#	"под себя". Функция numpy.set_printoptions принимает несколько аргументов:

	precision
	# количество отображаемых цифр после запятой (по умолчанию 8).

	threshold
	# количество элементов в массиве, вызывающее обрезание элементов 
	# (по умолчанию 1000).

	edgeitems 
	# количество элементов в начале и в конце каждой размерности массива 
	# (по умолчанию 3).

	linewidth
	# количество символов в строке, после которых осуществляется перенос 
	# (по умолчанию 75).

	suppress
	# если True, не печатает маленькие значения в scientific notation 
	# (по умолчанию False).

	nanstr
	# строковое представление NaN (по умолчанию 'nan').

	infstr
	# строковое представление inf (по умолчанию 'inf').

	formatter 
	# позволяет более тонко управлять печатью массивов.



Манипуляции с формой
Как уже говорилось, у массива есть форма (shape), определяемая числом элементов вдоль каждой оси:

>>>
>>> a
array([[[  0,   1,   2],
        [ 10,  12,  13]],

       [[100, 101, 102],
        [110, 112, 113]]])
>>> a.shape
(2, 2, 3)
Форма массива может быть изменена с помощью различных команд:

>>>
>>> a.ravel()  # Делает массив плоским
array([  0,   1,   2,  10,  12,  13, 100, 101, 102, 110, 112, 113])
>>> a.shape = (6, 2)  # Изменение формы
>>> a
array([[  0,   1],
       [  2,  10],
       [ 12,  13],
       [100, 101],
       [102, 110],
       [112, 113]])
>>> a.transpose()  # Транспонирование
array([[  0,   2,  12, 100, 102, 112],
       [  1,  10,  13, 101, 110, 113]])
>>> a.reshape((3, 4))  # Изменение формы
array([[  0,   1,   2,  10],
       [ 12,  13, 100, 101],
       [102, 110, 112, 113]])
Порядок элементов в массиве в результате функции ravel() соответствует обычному "C-стилю", то есть, чем правее индекс, тем он "быстрее изменяется": за элементом a[0,0] следует a[0,1]. Если одна форма массива была изменена на другую, массив переформировывается также в "C-стиле". Функции ravel() и reshape() также могут работать (при использовании дополнительного аргумента) в FORTRAN-стиле, в котором быстрее изменяется более левый индекс.

>>>
>>> a
array([[  0,   1],
       [  2,  10],
       [ 12,  13],
       [100, 101],
       [102, 110],
       [112, 113]])
>>> a.reshape((3, 4), order='F')
array([[  0, 100,   1, 101],
       [  2, 102,  10, 110],
       [ 12, 112,  13, 113]])
Метод reshape() возвращает ее аргумент с измененной формой, в то время как метод resize() изменяет сам массив:

>>>
>>> a.resize((2, 6))
>>> a
array([[  0,   1,   2,  10,  12,  13],
       [100, 101, 102, 110, 112, 113]])
Если при операции такой перестройки один из аргументов задается как -1, то он автоматически рассчитывается в соответствии с остальными заданными:

>>>
>>> a.reshape((3, -1))
array([[  0,   1,   2,  10],
       [ 12,  13, 100, 101],
       [102, 110, 112, 113]])
Объединение массивов
Несколько массивов могут быть объединены вместе вдоль разных осей с помощью функций hstack и vstack.

hstack() объединяет массивы по первым осям, vstack() — по последним:

>>>
>>> a = np.array([[1, 2], [3, 4]])
>>> b = np.array([[5, 6], [7, 8]])
>>> np.vstack((a, b))
array([[1, 2],
       [3, 4],
       [5, 6],
       [7, 8]])
>>> np.hstack((a, b))
array([[1, 2, 5, 6],
       [3, 4, 7, 8]])
Функция column_stack() объединяет одномерные массивы в качестве столбцов двумерного массива:

>>>
>>> np.column_stack((a, b))
array([[1, 2, 5, 6],
       [3, 4, 7, 8]])
Аналогично для строк имеется функция row_stack().

>>>
>>> np.row_stack((a, b))
array([[1, 2],
       [3, 4],
       [5, 6],
       [7, 8]])
Разбиение массива
Используя hsplit() вы можете разбить массив вдоль горизонтальной оси, указав либо число возвращаемых массивов одинаковой формы, либо номера столбцов, после которых массив разрезается "ножницами":

>>>
>>> a = np.arange(12).reshape((2, 6))
>>> a
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11]])
>>> np.hsplit(a, 3)  # Разбить на 3 части
[array([[0, 1], [6, 7]]),
 array([[2, 3], [8, 9]]),
 array([[ 4,  5], [10, 11]])]
>>> np.hsplit(a, (3, 4))  # Разрезать a после третьего и четвёртого столбца
[array([[0, 1, 2], [6, 7, 8]]),
 array([[3], [9]]),
 array([[ 4,  5], [10, 11]])]
Функция vsplit() разбивает массив вдоль вертикальной оси, а array_split() позволяет указать оси, вдоль которых произойдет разбиение.
Копии и представления
При работе с массивами, их данные иногда необходимо копировать в другой массив, а иногда нет. Это часто является источником путаницы. Возможно 3 случая:

Вообще никаких копий
Простое присваивание не создает ни копии массива, ни копии его данных:

>>>
>>> a = np.arange(12)
>>> b = a  # Нового объекта создано не было
>>> b is a  # a и b это два имени для одного и того же объекта ndarray
True
>>> b.shape = (3,4)  # изменит форму a
>>> a.shape
(3, 4)
Python передает изменяемые объекты как ссылки, поэтому вызовы функций также не создают копий.
Представление или поверхностная копия
Разные объекты массивов могут использовать одни и те же данные. Метод view() создает новый объект массива, являющийся представлением тех же данных.

>>>
>>> c = a.view()
>>> c is a
False
>>> c.base is a  # c это представление данных, принадлежащих a
True
>>> c.flags.owndata
False
>>>
>>> c.shape = (2,6)  # форма а не поменяется
>>> a.shape
(3, 4)
>>> c[0,4] = 1234  # данные а изменятся
>>> a
array([[  0, 1, 2, 3],
       [1234, 5, 6, 7],
       [ 8, 9, 10, 11]])
Срез массива это представление:

>>>
>>> s = a[:,1:3]
>>> s[:] = 10
>>> a
array([[  0, 10, 10, 3],
       [1234, 10, 10, 7],
       [ 8, 10, 10, 11]])
Глубокая копия
Метод copy() создаст настоящую копию массива и его данных:

>>>
>>> d = a.copy()  # создается новый объект массива с новыми данными
>>> d is a
False
>>> d.base is a  # d не имеет ничего общего с а
False
>>> d[0, 0] = 9999
>>> a
array([[  0, 10, 10, 3],
       [1234, 10, 10, 7],
       [ 8, 10, 10, 11]])