# i = 5

# while i < 15:
# 	print(i)
# 	i += 1
	

# ////////////////////////////////////

# test1 = 34
# test2 = 57

# if test1 < 50 and test2 > 50:
# 	print("Hellow")

# ////////////////////////////////////

# name = bool("Slava")

# if name == True:
# 	print("Hellow")
# else:
# 	print("Bad")

# //////////////////////////////////////

# import random 	#импортируем модуль

# test = random.randrange(1, 10)
# print(test)

# ////////////////////////////////////////

# для длиного текста применяются ('''example''')
# test = '''jwejwegr 2364527 sdjfhgsjdf
# 		5142315341341 764524726425273
# 		jsdfhgsjfgsjsfdhsdfhsdfgjshsj
# 	   '''

# # методы работы со строками
# print(len(test)) 			# длина строки
# print(test[27])				# обращение по индексу
# print(test[3:8])			# делаем срез по индексу от, до
# print(test[1:27:2])			# делаем срез с шагом
# print(test.isdigit())		# состоит ли строка из цифр
# print(test.isalpha())		# состоит ли строка из букв
# print(test.isalnum())		# состоит ли строка из цифр и букв
# print(test.islower())		# сотсоит ли строка из символов в нижнем регистре
# print(test.isupper())		# состоит ли строка из символов в верхнем регистре
# print(test.upper())			# преобразование строки к верхнему регистру
# print(test.lower())			# преобразование строки к нижнему регистру
# print(test.capitalize())	# переводит первый символ строки в верхний регистр, а все остальные в нижний


# ////////////////////////////////////////////////////////
# Форматирование строк. //////////////////////////////////

# import random

# test0 = random.randrange(1, 3)
# test1 = 'jhdjf'
# test2 = 2
# test3 = len(test1)

# print("test: {test[0]}".format(test = [test0, test1, test2, test3]))
# print('{2},{0},{1}'.format('a', 'b', 'c'))

# print('{:>30}'.format('right align'))
# print('{:^30}'.format('center'))

# points = 19.5
# total = 22

# print('test: {:.2%}'.format(points/total))

# ///////////////////////////////////////////////////////
# Cписки (list). ////////////////////////////////////////

# методы списков
# list.append(x)		Добавляет элемент в конец списка
# list.extend(L)		Расширяет список list, добавляя в конец все элементы списка L
# list.insert(i, x)		Вставляет на i-ый элемент значение x
# list.remove(x)		Удаляет первый элемент в списке, имеющий значение x. ValueError, если такого элемента не существует
# list.pop([i])			Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент
# list.count(x)			Возвращает количество элементов со значением x
# list.reverse()		Разворачивает список
# list.copy()			Поверхностная копия списка
# list.clear()			Очищает список

# list.index(x, [start, [end]])		Возвращает положение первого элемента со значением x 
# 									(при этом поиск ведется от start до end)
# list.sort([key = function])		Сортирует список на основе функции

# print(list("test")) 	# ['t', 'e', 's', 't']

# s = [] 	# пустой список 

# test = ['e', 'f', ['var'], 3]

# # генератор списков
# test2 = [c * 3 for c in 'test']
# test3 = [c * 3 for c in 'test3' if c != '3']

# s1 = ['ewu', 'wety', test, 987]
# s.extend(s1)
# print(s)


# ////////////////////////////////////////////////////////
# Индексы и срезы. ///////////////////////////////////////

# В данном примере переменная a являляется списком,
# 	однако взять элемент по индексу можно и у других типов: строк, кортежей.

# a = [1, 3, 8, 7]

# print(a[3])

# # срезы

# # item[START:STOP:STEP] - берёт срез от номера START, 
# # 	до STOP (не включая его), с шагом STEP. 
# # 		По умолчанию START = 0, STOP = длине объекта, 
# # 			STEP = 1. Соответственно, какие-нибудь 
# # 				(а возможно, и все) параметры могут быть опущены.

# a[1:3] = [0, 0, 0]
# del a[:-3]


# /////////////////////////////////////////////////////////
# Кортежи (tuple). ////////////////////////////////////////

# Кортеж, по сути - неизменяемый список.
# 	- защищенный от изменений;
# 	- меньший размер получить размер (tuple._sizeof_()); 

	# a = (1, 2, 3, 4, 5, 6) # 72
	# b = [1, 2, 3, 4, 5, 6] # 88

#	- возможность использовать кортежи в качестве ключей словаря;

	# d = {(1, 1, 1) : 1} # {(1, 1, 1): 1}
	# d = {[1, 1, 1] : 1} # TypeError

# Работа с кортежами.

# test = tuple() 	# создали кортеж с помощью встроенной функции
# test2 = () 		# создали кортеж с помощью литерала кортежа
# test3 = 's', 	# можно и так, но лучше не использовать

# a, b = b, a 	# меняем местами значение двух переменных


# ///////////////////////////////////////////////////////////
# Словари (dict). ///////////////////////////////////////////

# Неупорядоченные коллекции произвольных объектов с доступом по ключу. 
# 	Их иногда ещё называют ассоциативными массивами или хеш-таблицами.
# 		Что же можно делать со словарями? То же самое, что и с другими 
# 			объектами: встроенные функции, ключевые слова 
# 				(например, циклы for и while), а также специальные методы 
#					словарей.

# d = {} 					# создаём словарь с помощью литерала
# d = dict() 				# создание словаря с помошью метода dict()

# d = dict.fromkeys(['a', 'b'], 100)   # с помощью метода fromkeys()
# print(d) # {'a': 100, 'b': 100}

# x = {a: a ** 2 for a in range(7)} # создание с помощью генератора
# print(x) # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}

# test = {1: 2, 2: 3, 'test': 4}
# test['test'] # 4

# методы словарей
# dict.clear()			очищает словарь.
# dict.copy()			возвращает копию словаря.
# dict.items()			возвращает пары (ключ, значение).
# dict.keys()			возвращает ключи в словаре.
# dict.popitem()		удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение KeyError. Помните, что словари неупорядочены.
# dict.values()			возвращает значения в словаре.
# dict.update([other])	обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Возвращает None (не новый словарь!).

# classmethod dict.fromkeys(seq[, value])	создает словарь с ключами из seq и значением value (по умолчанию None).
# dict.get(key[, default])					возвращает значение ключа, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).
# dict.pop(key[, default])					удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).
# dict.setdefault(key[, default])			возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ с значением default (по умолчанию None).


test = {1: 2, 2: 'jhgs', 'go': 5}
test3 = test.copy()




# ////////////////////////////////////////////////////////////
# Множества (set и frozenset). ///////////////////////////////