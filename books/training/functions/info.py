#	Function ::::::::::::::::::::::::::::::::::::::::::::::::::::::

#	Виды сопоставления аргументов функций .........................

	func(value)
	# Обычный аргумент: сопоставление производится по позиции

	func(name=value)
	# Именованный аргумент: сопоставление производится по 
	# указанному имени

	func(*sequence)
	# Все объекты в указанной последовательности передаются как 
	# отдельные позиционные аргументы

	func(**dict)
	# Все пары ключ/значение в указанном словаре передаются как
	# отдельные именованные аргументы

	def func(name)
	# Обычный аргумент: сопоставление производится по позиции или 
	# по имени

	def func(name=value)
	# Значение аргумента по умолчанию, на случай, если аргумент не 
	# передается функции

	def func(*name)
	# Определяет и объединяет все дополнительные аргументы в 
	# кортеж

	def func(**name)
	# Определяет и объединяет все дополнительные именованные
	# аргументы в словарь

	def func(*args, name)
	# Аргументы, которые должны передаваться функции только по именам

#	.................................................................

#	Сбор аргументов в коллекцию .....................................

	def f(*args): print(args)
	f(1,2,3,4) 	# (1, 2, 3, 4)

	# При вызове этой функции интерпретатор Python соберет все 
	# позиционные аргументы в  новый кортеж и  присвоит этот кортеж 
	# переменной args. Это будет обычный объект кортежа, поэтому из 
	# него можно извлекать элементы по индексам, выполнять обход в 
	# цикле for и так далее.

	def f(**args): print(args)
	f(a=1, b=2) 	# {‘a’: 1, ‘b’: 2}

	# Комбинация ** дает похожий результат, но применяется при 
	# передаче именованных аргументов – в этом случае аргументы будут 
	# собраны в новый словарь, который можно обрабатывать обычными 
	# инструментами, предназначенными для работы со словарями.

#	.................................................................

#	Извлечение аргументов из коллекции ..............................

	def func(a, b, c, d): print(a, b, c, d)
	args = (1, 2, 3, 4)
	func(*args) 	# 1, 2, 3, 4

	# В  этом случае данная форма передачи аргументов имеет 
	# противоположный смысл по сравнению с  применением этой формы в 
	# определениях функций – она распаковывает, а не создает коллекцию 
	# аргументов.

	def func(a, b, c, d): print(a, b, c, d)
	args = {‘a’: 1, ‘b’: 2, ‘c’: 3}
	func(**args) 	# 1, 2, 3

	# Точно так же форма ** в вызовах функций распаковывает словари 
	# пар ключ/значение в отдельные аргументы, которые передаются по 
	# ключу.

#	.................................................................

