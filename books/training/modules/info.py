#	modules ::::::::::::::::::::::::::::::::::::::::::::::::::

	import
	# Позволяет клиентам (импортерам) получать модуль целиком.

	from
	# Позволяет клиентам получать определенные имена из модуля.

	imp.reload
	# Обеспечивает возможность повторной загрузки модуля без 
	# остановки интерпретатора Python.

	sys.path
	# это путь поиска модулей. Интерпретатор создает его во 
	# время запуска программы, автоматически объединяя в  список 
	# домашний каталог (или пустую строку, что соответствует 
	# текущему рабочему каталогу) все каталоги, перечисленные в  
	# переменной окружения PYTHONPATH и  в файлах .pth, и  каталоги 
	# стандартной библиотеки. В  результате получается список строк 
	# с  именами каталогов, которые просматриваются интерпретатором 
	# при импортировании новых файлов.

	from .spam import name
	# означает: «из модуля с  именем spam, расположенного в  том же 
	# пакете, что и файл, где находится эта инструкция, импортировать 
	# переменную name».

	# Возможны также и другие варианты точечной нотации для ссылки на 
	# модули в пакете. Допустим, что имеется каталог mypkg пакета, 
	# тогда следующие альтернативные варианты импортирования внутри 
	# этого пакета будут работать так, как описывается:

	from .string import name1, name2 	# Импорт имен из mypkg.string
	from . import string 				# Импорт mypkg.string
	from .. import string	# Импорт string из родительского каталога

#	..............................................................

#	Смешанные режимы использования: __name__ и __main__ ..........

#	Если файл запускается как главный файл программы, атрибуту 
#	__name__ на запуске присваивается значение “__main__”.

#	Если файл импортируется, атрибуту __name__ присваивается имя 
#	модуля, под которым он будет известен клиенту.

#	Благодаря этому модуль может проверить собственный атрибут 
#	__name__ и определить, был ли он запущен как самостоятельная 
#	программа или импортирован другим модулем. Например, предположим, 
#	что мы создаем файл модуля с именем runme.py, который экспортирует 
#	единственную функцию с именем tester:

	def tester():
		print(“It’s Christmas in Heaven...”)

	if __name__ == ‘__main__’:
		tester()	# Только когда запускается, а не импортируется

#	Этот модуль определяет функцию для клиентов и может импортироваться 
#	как обычный модуль:

	import runme
	runme.tester() 	# It’s Christmas in Heaven...

#	Но в самом конце модуля имеется программный код, который вызывает 
#	функцию, когда этот файл запускается как самостоятельная программа:

	runme.py 	# It’s Christmas in Heaven...
