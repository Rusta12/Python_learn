Operator overloading ::::::::::::::::::::::::::::::::::::::::::::::::

# 

# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

__new__(cls[, ...])	
# управляет созданием экземпляра. В качестве обязательного 
# аргумента принимает класс (не путать с экземпляром). Должен
# возвращать экземпляр класса для его последующей передачи
# методу __init__.

__init__(self[, ...])
# При создании экземпляра класса интерпретатор автоматически вызывает 
# метод инициали­зации __init__(). В других языках программирования 
# такой метод принято называть кон­структором класса. С помощью метода 
# __init__() можно присвоить начальные значения атрибутам класса.
# При создании экземпляра класса параметры этого метода указываются 
# после имени класса в круглых скобках

__del__(self)
# Если конструктор вызывается при создании объекта, то перед 
# уничтожением объекта авто­матически вызывается метод, называемый 
# деструктором. В языке Python деструктор реа­лизуется в виде 
# предопределенного метода __del__(). Следует заметить, что метод не 
# будет вызван, если на экземпляр класса существует хотя бы одна ссылка. 
# Впрочем, поскольку интерпретатор самостоятельно заботится об удалении 
# объектов, использование деструктора в языке Python не имеет особого 
# смысла.

__repr__(self)
# вызывается при выводе в интерактивной оболочке, а также при использова­
# нии функции repr()

__str__(self) 
# вызывается при выводе с помощью функции print(), а также при 
# использовании функции str(). Если метод __str__() отсутствует, то будет 
# вызван метод __repr__()

__bytes__(self) 
# вызывается функцией bytes при преобразовании к байтам.

__format__(self, format_spec) 
# используется функцией format (а также методом format у строк).

__hash__(self) 
# получение хэш-суммы объекта, например, для добавления в словарь.
# этот метод следует переопределить, если экземпляр класса планиру­ется 
# использовать в качестве ключа словаря или внутри множества.

__bool__(self) 
# вызывается при проверке истинности. Если этот метод не определён, 
# вызывается метод __len__ (объекты, имеющие ненулевую длину, 
# считаются истинными).
# вызывается при использовании функции bool()

__getattr__(self, name) 
# вызывается, когда атрибут экземпляра класса не найден в обычных 
# местах (например, у экземпляра нет метода с таким названием).

__getattribute__(self, atribute)
# вызывается при обращении к любому атрибуту класса. Необходимо учитывать, 
# что использование точечной нотации (для обращения к атрибуту класса) 
# внутри этого метода приведет к зацикливанию. Чтобы избежать за­цикливания, 
# следует вызывать мeтoд __getattribute__() объекта object. Внутри метода
# нужно вернуть значение атрибута или возбудить исключение AttributeError.

__setattr__(self, name, value) 
# вызывается при попытке присваивания значения атрибуту экземпляра класса. 
# Если внутри метода необходимо присвоить зна­чение атрибуту, то следует 
# использовать словарь __dict__, иначе при точечной нотации метод 
# __setattr__() будет вызван повторно, что приведет к зацикливанию.

__delattr__(self, name)
# удаление атрибута (del obj.name).

__call__(self[, args...]) 
# позволяет обработать вызов экземпляра класса как вызов функции

__len__(self) 
# вызывается при использовании функции len(), а также для проверки объекта 
# на логическое значение при отсутствии метода __bool__(). Метод должен 
# воз­врашать положительное целое число.

__getitem__(self, index) 
# вызывается при извлечении элемента последовательно­сти по его индексу с 
# помощью операции 'Экземпляр класса[Индекс]. Должен воз­вращать значение, 
# расположенное по этому индексу. Если индекс не является целым числом или 
# срезом, должно возбуждаться исключение TypeError, если такового индекса
# не существует, следует возбудить исключение IndexError

__setitem__(self, индекс, зна­чение) 
# вызывается в случае присваивания нового значения элементу 
# последовательности с заданным индексом (операция 
# 'Экземпляр класса[Индекс] = Новое значение'. Метод не должен возвращать 
# результата. В случае задания индекса недопустимого типа и отсутствия 
# такого индекса в последова­тельности следует возбуждать те же исключения, 
# что и в случае метода __getitem__()

__delitem__(self, key) 
# вызывается в случае удаления элемента последователь­ности с заданным 
# индексом с помощью выражения del 'Экземпляр класса[Ключ]'. Метод не 
# должен возвращать результата. В случае задания индекса недопустимого 
# типа и отсутствия такого индекса в последовательности следует возбуждать 
# те же исключе­ния, что и в случае метода __getitem__()

__iter__(self) 
# говорит о том, что этот класс является итератором (поддерживает 
# итерационный протокол, как говорят Руthоn-программисты). Должен возвращать 
# сам эк­земпляр этого класса, а также при необходимости может выполнять 
# всевозможные пре­дустановки.

__next__(self)
# вызывается при выполнении каждой итерации и должен возвращать очередное 
# значение из последовательности. Если последовательность закончилась, в 
# этом методе следует возбудить исключение StopIteration, которое сообщит 
# вызы­вающему коду об окончании итераций.

__reversed__(self) 
# итератор из элементов, следующих в обратном порядке.




# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# Перегрузка арифметических операторов

__add__(self, other) 
# сложение. x + y вызывает x.__add__(y).

__sub__(self, other)
# х - у - вычитание: x.__suЬ__(y)

__mul__(self, other)
# x * y - умножение: х.___mul__(у)

__truediv__(self, other) 
# x / у - деление: х.__truediv__(у)

__floordiv__(self, other)
# х // у - деление с округлением вниз: х.__floordiv__(y)

__mod__(self, other)
# x % у - остаток от деления: х.__mod__(у)

__divmod__(self, other)
# частное и остаток (divmod(x, y)).

__pow__(self, other[, modulo])
# x ** y - возведение в степень: х.__pow__(у)

__radd__(self, other)
# сложение (экземпляр класса справа)

__rsub__(self, other)
# у - х - вычитание (экземпляр класса справа): х.__rsuЬ__(y)

__rmul__(self, other)
# у * х - умножение (экземпляр класса справа): x.__mul__(y)

__rtruediv__(self, other)
# у / х - деление (экземпляр класса справа): x.__rtruediv__(y)

__rfloordiv__(self, other)
# у // х - деление с округлением вниз (экземпляр класса справа): 
# x.__rfloordiv__(y)

__rmod__(self, other)
# y % x - остаток от деления (экземпляр класса справа): x.__rmod__(y)

__rdivmod__(self, other)

__rpow__(self, other)
# y ** x - возведение в степень (экземпляр класса справа): x.__rpow__(y)

__iadd__(self, other)
# х += у - сложение и присваиваниех: х.__iadd__(у)

__isub__(self, other)
# х -= у - вычитание и присваивание: x.__isub__(y)

__imul__(self, other)
# х *= у - умножение и присваивание: х.__imul__(у)

__itruediv__(self, other)
# х /= у - деление и присваивание: x.__itruediv__(y)

__ifloordiv__(self, other)
# х //= у - деление с округлением вниз и присваивание: x.__ifloordiv__(y)
 
__imod__(self, other) 
# x %= y - остаток от деления и присваивание: x.__imod__(y)

__ipow__(self, other[, modulo])
# x **= y - возведение в степень и присваивание: х.__ipow__(у)

__neg__(self)
# -x - унарный минус: x.__neg__()

__pos__(self) 
# +x - унарный плюс: x.__pos__(self)

__abs__(self) 
# abs(x) - абсолютное значение x.__abs__()

__complex__(self)
# вызывается при преобразовании объекта в комплексное число с помощью функции
# complex().

__int__(self
# вызывается при преобразовании объекта в целое число с помощь функции int()

__float__(self)
# вызывается при преобразовании объекта в вещественное число с помощью функции 
# float().

__round__(self[, n])
# вызывается при использовании функции round()

__enter__(self)
# вызывается после создания объекта. Значение, возвращаемое этим методом,
# присваивается переменной, указанной после ключевого слова as. Если переменная 
# не ука­зана, возвращаемое значение игнорируется 

__exit__(self, exc_type, exc_value, traceback)
# Если при выполнении внутри тела инструкции with воз­никло исключение, то 
# управление передается методу __exit__()
# Значения, доступные через последние три параметра, полностью эквивалентны 
# значениям, возвращаемым функцией exc_info() из модуля sys. Если исключение 
# обработано, метод должен вернуть значение True, в противном случае - False. 
# Если метод возвращает False, то исключение передается вышестоящему обработчику.
# Если при выполнении инструкций, расположенных внутри тела инструкции with, 
# исключе­ние не возникло, то управление все равно передается методу __exit__(). 
# В этом случае по­следние три параметра будут содержать значение None.

__index__(self)
# вызывается при использовании функций Ьin(), hex() и oct()




# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# методы перезагрузки двоичных операторов

__rrshift__(self, other)
# y >> x - сдвиг вправо (экземпляр класса справа): х.___rrshift__(y)

__irshift__(self, other)
# x >>= y - сдвиг вправо и присваивание: х.__irshift__(y)

__invert__(self) 
# ~x - двоичная инверсия: x.__inver__()

__lshift__(self, other) 
# x << y - сдвиг влево: x.__lshift__(y)

__rlshift__(self, other)
# y << x - сдвиг влево (экземпляр класса справа): х.__rlshift__(y)

__ilshift__(self, other)
# x <<= y - сдвиг влево и присваивание: x.__ilshift__(y)

__rshift__(self, other) 
# x >> y - сдвиг вправо: х.__rshift__(y)

__and__(self, other) 
# x & y - двоичное И: x.__and__(y)

__rand__(self, other)
# y & x - двоичное И (экземпляр класса справа): x.__rand__(y)

__iand__(self, other)
# x &= y - двоичное И и присваивание: х.__iand__(y)

__xor__(self, other) 
# x ^ y - двоичное исключающее ИЛИ: x.__xor__(y)

__rxor__(self, other)
# y ^ x - двоичное исключающее ИЛИ (экземпляр класса справа): x.__rxor__(y)

__ixor__(self, other)
# x ^= y - двоичное искточающее ИЛИ и присваивание: x.__ixor__(y)

__or__(self, other) 
# x | y - двоичное ИЛИ: x.__or__(y)

__ror__(self, other)
# y | x - двоичное ИЛИ (экземпляр класса справа): х.__ror__(у)

__ior__(self, other)
# x |= y - двоичное ИЛИ и присваивание: х.__ior__(у)




# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# Перегрузка операторов сравнения

__lt__(self, other) 
# x < y - меньше: x.__lt__(y).

__le__(self, other)
# x ≤ y - меньше или равно: x.__le__(y).

__eq__(self, other) 
# x == y - равно: x.__eq__(y).

__ne__(self, other) 
# x != y - не равно: x.__ne__(y)

__gt__(self, other) 
# x > y - больше: x.__gt__(y).

__ge__(self, other) 
# x ≥ y - больше или равно: x.__ge__(y).

__contains__(self, item) 
# y in x - проверкана вхождение: x.__contains__(y)
# вызывается при проверке существования заданного значения в 
# последовательности с применением операторов in и not in. Должен возвра­щать 
# True, если такое значение есть, и False - в противном случае



# atributes ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

__bases__
# используется для получения перечня базовых классов. В качестве значения 
# атрибут возвращает кортеж.

__mro__
# позволяет получить всю цепочку наследования

__slots__
# Ограничивает перечень атрибутов, разрешенных для экземпляров класса. Для 
# этого разрешенные атрибуты перечисляются внутри класса в атрибуте __slots__. 
# В качест­ве значения атрибуту можно присвоить строку или список строк с 
# названиями идентифика­торов. Если производится попытка обращения к атрибуту, 
# не перечисленному в __slots__, то возбуждается исключение AttributeError