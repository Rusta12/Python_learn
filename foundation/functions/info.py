#	Function ::::::::::::::::::::::::::::::::::::::::::::::::::::::

#	Виды сопоставления аргументов функций .........................

	func(value)
	# Обычный аргумент: сопоставление производится по позиции

	func(name=value)
	# Именованный аргумент: сопоставление производится по 
	# указанному имени

	func(*args)
	# Все объекты в указанной последовательности передаются как 
	# отдельные позиционные аргументы

	func(**kwargs)
	# Все пары ключ/значение в указанном словаре передаются как
	# отдельные именованные аргументы

	def func(name)
	# Обычный аргумент: сопоставление производится по позиции или 
	# по имени

	def func(name=value)
	# Значение аргумента по умолчанию, на случай, если аргумент не 
	# передается функции

	def func(*name)
	# Определяет и объединяет все дополнительные аргументы в 
	# кортеж

	def func(**name)
	# Определяет и объединяет все дополнительные именованные
	# аргументы в словарь

	def func(*args, name)
	# Аргументы, которые должны передаваться функции только по именам

#	.................................................................

#	Сбор аргументов в коллекцию .....................................

	def f(*args): print(args)
	f(1,2,3,4) 	# (1, 2, 3, 4)

	# При вызове этой функции интерпретатор Python соберет все 
	# позиционные аргументы в  новый кортеж и  присвоит этот кортеж 
	# переменной args. Это будет обычный объект кортежа, поэтому из 
	# него можно извлекать элементы по индексам, выполнять обход в 
	# цикле for и так далее.

	def f(**args): print(args)
	f(a=1, b=2) 	# {‘a’: 1, ‘b’: 2}

	# Комбинация ** дает похожий результат, но применяется при 
	# передаче именованных аргументов – в этом случае аргументы будут 
	# собраны в новый словарь, который можно обрабатывать обычными 
	# инструментами, предназначенными для работы со словарями.

#	.................................................................

#	Извлечение аргументов из коллекции ..............................

	def func(a, b, c, d): print(a, b, c, d)
	args = (1, 2, 3, 4)
	func(*args) 	# 1, 2, 3, 4

	# В  этом случае данная форма передачи аргументов имеет 
	# противоположный смысл по сравнению с  применением этой формы в 
	# определениях функций – она распаковывает, а не создает коллекцию 
	# аргументов.

	def func(a, b, c): print(a, b, c)
	args = {‘a’: 1, ‘b’: 2, ‘c’: 3}
	func(**args) 	# 1, 2, 3

	# Точно так же форма ** в вызовах функций распаковывает словари 
	# пар ключ/значение в отдельные аргументы, которые передаются по 
	# ключу.

#	.................................................................

#	Yield ...........................................................

#	Главное отличие функций-генераторов от обычных функций состоит в 
#	том, что функция-генератор поставляет значение, а не возвращает 
#	его – инструкция yield приостанавливает работу функции и  передает 
#	значение вызывающей программе, при этом сохраняется информация о  
#	состоянии, необходимая, чтобы возобновить работу с  того места, где 
#	она была приостановлена. Когда функция-генератор возобновляет работу, 
#	ее выполнение продолжается с  первой инструкции, следующей за 
#	инструкцией yield.

	def timesfour(S):
		for i in S:
			yield i * 2

	G = timesfour('spam')
	list(G)



# ::::::::::::
Example 	# ::::::::::
# ::::::::::::


ex = 'example'
def test():
	ex = 'locals variable'
	print('locals:',locals())
	print('globals:', globals())
ex # 'example'
test() 	# 'locals: {'ex': 'locals variable'}'
		# 'globals: {'ex': 'example'}'


# 	Анонимные функции, инструкция lambda...............................

# 	Анонимные функции могут содержать лишь одно выражение, но и 
# 	выполняются они быстрее. Анонимные функции создаются с помощью 
# 	инструкции lambda. Их не обязательно присваивать переменной, 
# 	как c инструкцией def func()

	func = lambda x, y: x + y
	(lambda x, y: x + y)(1, 2)
	(lambda x, y: x + y)('a', 'b')

#	lambda функции, в отличие от обычной, не требуется инструкция 
# 	return, а в остальном, ведет себя точно так же.

	func = lambda *args: args