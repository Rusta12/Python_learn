# 	////////////////////////////////////////////////////////////
# 	Работа с модулями: создание, подключение инструкциями 
#	import и from //////////////////////////////////////////////

#	Модулем в Python называется любой файл с программой.

#	Каждая программа может импортировать модуль и получить доступ 
#	к его классам, функциям и объектам. Нужно заметить, что модуль
#	может быть написан не только на Python, а например, на C или C++.


#	modules ::::::::::::::::::::::::::::::::::::::::::::::::::

	import
	# Позволяет клиентам (импортерам) получать модуль целиком.

	from
	# Позволяет клиентам получать определенные имена из модуля.

	imp.reload
	# Обеспечивает возможность повторноkй загрузки модуля без 
	# остановки интерпретатора Python.

	sys.path
	# это путь поиска модулей. Интерпретатор создает его во 
	# время запуска программы, автоматически объединяя в  список 
	# домашний каталог (или пустую строку, что соответствует 
	# текущему рабочему каталогу) все каталоги, перечисленные в  
	# переменной окружения PYTHONPATH и  в файлах .pth, и  каталоги 
	# стандартной библиотеки. В  результате получается список строк 
	# с  именами каталогов, которые просматриваются интерпретатором 
	# при импортировании новых файлов.

	from .spam import name
	# означает: «из модуля с  именем spam, расположенного в  том же 
	# пакете, что и файл, где находится эта инструкция, импортировать 
	# переменную name».

	# Возможны также и другие варианты точечной нотации для ссылки на 
	# модули в пакете. Допустим, что имеется каталог mypkg пакета, 
	# тогда следующие альтернативные варианты импортирования внутри 
	# этого пакета будут работать так, как описывается:

	from .string import name1, name2 	# Импорт имен из mypkg.string
	from . import string 				# Импорт mypkg.string
	from .. import string	# Импорт string из родительского каталога

#	..............................................................

#	Смешанные режимы использования: __name__ и __main__ ..........

#	Если файл запускается как главный файл программы, атрибуту 
#	__name__ на запуске присваивается значение “__main__”.

#	Если файл импортируется, атрибуту __name__ присваивается имя 
#	модуля, под которым он будет известен клиенту.

#	Благодаря этому модуль может проверить собственный атрибут 
#	__name__ и определить, был ли он запущен как самостоятельная 
#	программа или импортирован другим модулем. Например, предположим, 
#	что мы создаем файл модуля с именем runme.py, который экспортирует 
#	единственную функцию с именем tester:

	def tester():
		print("It’s Christmas in Heaven...")

	if __name__ == ‘__main__’:
		tester()	# Только когда запускается, а не импортируется

#	Этот модуль определяет функцию для клиентов и может импортироваться 
#	как обычный модуль:

	import runme
	runme.tester() 	# It’s Christmas in Heaven...

#	Но в самом конце модуля имеется программный код, который вызывает 
#	функцию, когда этот файл запускается как самостоятельная программа:

	runme.py 	# It’s Christmas in Heaven...


#	Использование псевдонимов..................................

#	Если название модуля слишком длинное, или оно не нравится 
#	по каким-то другим причинам, то для него можно создать 
#	псевдоним, с помощью ключевого слова as.

	import math as m
	m.e 				# 2.718281828459045

#	Теперь доступ ко всем атрибутам модуля math осуществляется 
#	только с помощью переменной m, а переменной math в этой 
#	программе уже не будет.

	from math import e, ceil as c
	e 								# 2.718281828459045
	c(4.6) 							# 5

#	Импортируемые атрибуты можно разместить на нескольких строках, 
#	если их много, для лучшей читаемости кода:

	from math import (sin, cos,
			          tan, atan)

#	Второй формат инструкции from позволяет подключить все 
#	(точнее, почти все) переменные из модуля. Для примера 
#	импортируем все атрибуты из модуля sys:

	from sys import *
	version
	# '3.3.2 (v3.3.2:d047928ae3f6, May 16 2013, 00:03:43) [MSC v.1600 32 bit (Intel)]'
	version_info
	sys.version_info(major=3, minor=3, micro=2, releaselevel='final', serial=0)

#	Следует заметить, что не все атрибуты будут импортированы. Если 
#	в модуле определена переменная __all__ (список атрибутов, 
#	которые могут быть подключены), то будут подключены только 
#	атрибуты из этого списка. Если переменная __all__ не определена, 
#	то будут подключены все атрибуты, не начинающиеся с нижнего 
#	подчёркивания. Кроме того, необходимо учитывать, что импортирование 
#	всех атрибутов из модуля может нарушить пространство имен главной 
#	программы, так как переменные, имеющие одинаковые имена, будут 
#	перезаписаны.

#	Создание своего модуля............................................

#	Создадим файл mymodule.py, в которой определим какие-нибудь функции:

	def hello():
    	print('Hello, world!')

	def fib(n):
    	a = b = 1
    	
    	for i in range(n - 2):
        	a, b = b, a + b
    	return b

#	Теперь в этой же папке создадим другой файл, например, main.py:

	import mymodule

	mymodule.hello() 		# Hello, world!
	print(mymodule.fib(10)) # 55

#	Куда поместить модуль?............................................

#	Пути поиска модулей указаны в переменной sys.path. В него включены 
#	текущая директория (то есть модуль можно оставить в папке с основной 
#	программой), а также директории, в которых установлен python. Кроме 
#	того, переменную sys.path можно изменять вручную, что позволяет 
#	положить модуль в любое удобное для вас место (главное, не забыть в 
#	главной программе модифицировать sys.path).
