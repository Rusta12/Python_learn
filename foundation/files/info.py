files :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# Этот модуль 

# документация на английском:
# 

# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

open(files, mode='r', buffering=-1, encoding=None, errors=None, 
	newline=None, closefd=True)
# В первом параметре указывается путь к файлу. Путь может быть абсолютным 
# или относи­тельным. При указании абсолютного пути в Windows следует 
# учитывать, что в Python слеш является специальным символом. По этой 
# причине слеш необходимо удваивать или вместо обычных строк использовать 
# неформатированные строки.
# Вместо абсолютного пути к файлу можно указать относительный путь. В этом 
# случае путь определяется с учетом местоположения текушего рабочего 
# каталога. Относительный путь будет автоматически преобразован в 
# абсолютный путь с помощью функшrn abspath() из моду­ля os.path.

mode
# задаёт режим открытия файла
	'r'  # только чтение (значение по умолчанию). После открытия файла 
		 # указатель устанав­ливается на начало файла. Если файл не 
		 # существует, возбуждается исключение FileNotFoundError
	
	'r+' # чтение и запись. После открытия файла указатель устанавливается на 
		 # начало файла. Если файл не существует, то возбуждается исключение 
		 # FileNotFoundError

	'w'	 # запись. Если файл не существует, он будет создан. Если файл 
		 # существует, он будет перезаписан. После открытия файла указатель 
		 # устанавливается на начало файла

	'w+' # чтение и запись. Если файл не существует, он будет создан. Если 
		 # файл существует, он будет перезаписан. После открытия файла 
		 # указатель устанавливается на начало файла
	
	'x'	 # создание файла для записи. Если файл уже существует, возбуждается 
		 # исключение FileExistsError

	'x+' # создание файла для чтения и записи. Если файл уже существует, 
		 # возбуждается ис­ключение FileExistsError

	'a'	 # запись. Если файл не существует, он будет создан. Запись 
		 # осуществляется в конец файла. Содержимое файла не удаляется

	'a+' # чтение и запись. Если файл не существует, он будет создан. Запись 
		 # осуществляется в конец файла. Содержимое файла не удаляется

	'b'	 # файл будет открыт в бинарном режиме. Файловые методы принимают и 
		 # возвраща­ют объекты типа bytes
	
	't'	 # файл будет открыт в текстовом режиме (значение по умолчанию в Windows). 
		 # Фай­ловые методы принимают и возвращают объекты типа str. В этом режиме 
		 # будет автома­тически выполняться обработка символа конца строки - так, 
		 # в Windows при чтении вместо символов \r\n будет подставлен символ \n.

# Режимы могут быть объединены, то есть, к примеру, 'rb' - чтение в двоичном 
# режиме. По умолчанию режим равен 'rt'.

buffering
# Для ускорения работы производится буферизация записываемых данных. Информация из
# буфера записывается в файл полностью только в момент закрытия файла или после 
# вызова функции или метода flush(). В необязательном параметре buffering можно 
# указать размер буфера. Если в качестве значения указан 0, то данные будут сразу 
# записываться в файл (значение допустимо только в бинарном режиме). Значение 1 
# используется при построчной записи в файл (значение допустимо только в текстовом 
# режиме), другое положительное число задает примерный размер буфера, а 
# отрицательное значение (или отсутствие значе­ния) означает установку размера, 
# применяемого в системе по умолчанию. По умолчанию текстовые файлы буферизуются 
# построчно, а бинарные - частями, размер которых интер­претатор выбирает 
# самостоятельно в диапазоне от 4096 до 8192 байтов.

encoding
# При использовании текстового режима (задается по умолчанию) при чтении 
# производится попытка преобразовать данные в кодировку Unicode, а при записи 
# выполняется обратная операция - строка преобразуется в последовательность 
# байтов в определенной кодировке. По умолчаншо назначается кодировка, применяемая 
# в системе. Если преобразование невоз­можно, то возбуждается исключение. Указать 
# кодировку, которая будет использоваться при записи и чтении файла, позволяет 
# параметр encoding.

newline
# Параметр newline задает режим обработки символов конuа строк. Поддерживаемые им 
# зна­чения таковы:
	None 
	# (значение по умолчанmо)- выполняется стандартная обработка символов конца
	# строки. Например, в Windows при чтении символы \r\n преобразуются в символ 
	# \n, а при записи производится обратное преобразование
	"" 
	# (пустая строка)- обработка символов конца строки не выполняется
	"Специальный символ"
	# указанный специальный символ используется для обозначе­ния конца строки, и 
	# никакая дополнительная обработка не выполняется. В качестве спе­циального 
	# символа можно указать лишь \r\n, \r и \n


# methods :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

f.read(N)
# считывает данные из файла. Если файл открыт в текстовом режиме, то возвращается 
# строка, а если в бинарном - последовательность байтов. Если параметр не указан, 
# возвращается содержимое файла от текущей позиции указателя до конца файла
# Если в качестве параметра указать число, то за каждый вызов будет возвращаться 
# ука­занное количество символов или байтов. Когда достигается конец файла, метод 
# возвра­щает пустую строку.

f.readline(count)
# считывает из файла одну строку при каждом вызове. Если файл открыт в текстовом 
# режиме, то возвращается строка, а если в бинарном - после­довательность байтов. 
# Возвращаемая строка включает символ перевода строки. Исклю­чением является 
# последняя строка - если она не завершается символом перевода стро­ки, то таковой 
# добавлен не будет. При достижении конца файла возвращается пустая строка.
# Если в необязательном параметре указано число, то считывание будет выполняться 
# до тех пор, пока не встретится символ новой строки (\n), символ конца файла или 
# из файла не будет прочитано указанное количество символов. Иными словами, если 
# количество символов в строке меньше значения параметра, то будет считана одна 
# строка, а не ука­занное количество символов, а если количество символов в строке 
# больше, то возвраща­ется указанное количество символов.

f.readlines()
# считывает все содержимое файла в список. Каждый элемент списка бу­дет содержать 
# одну строку, включая символ перевода строки. Исключением является последняя 
# строка. Если она не завершается символом перевода строки, то символ пере­вода 
# строки добавлен не будет. Если файл открыт в текстовом режиме, то возвращается
# список строк, а если в бинарном - список объектов типа bytes.

f.write('text')
# записывает строку или последовательность байтов в файл. Если в качестве 
# параметра указана строка, то файл должен быть открыт в текстовом режиме.
# Для записи последовательности байтов необходимо открыть файл в бинарном 
# режиме. Помните, что нельзя записывать строку в бинарном режиме и 
# последовательность бай­тов в текстовом режиме. Метод возвращает количество 
# записанных символов или бай­тов.

f.writelines(list)
# записывает последовательность в файл. Если все элементы последовательности 
# являются строками, то файл должен быть открыт в тек­стовом режиме. Если все 
# элементы являются последовательностями байтов, то файл должен быть открыт в 
# бинарном режиме.

f.writable()
# возвращает True, если файл поддерживает запись, и False - в противном 
# случае

f.close()
# закрывает файл. Так как интерпретатор автоматически удаляет объект, когда
# на него отсутствуют ссылки, в небольших программах можно явно не закрывать 
# файл. Тем не менее, явное закрытие файла является признаком хорошего стиля 
# программиро­вания. Кроме того, при наличии незакрытого файла генерируется 
# предупреждающее со­общение: "ResourceWarning: unclosed file"

f.flush()
# принудительно записывает данные из буфера на диск

f.fileno()
# возвращает целочисленный дескриптор файла. Возвращаемое значение все­гда 
# будет больше числа 2, т.к. число О закреплено за стандартным вводом stdin, 
# 1 - за стандартным выводом stdout, а 2 - за стандартным выводом сообщений 
# об ошибках stderr.

f.truncate(count)
# обрезает файл до указанного количества символов (если задан текстовый режим) 
# или байтов (в случае бинарного режима). Метод возвращает но­вый размер файла.

f.tell()
# возвращает позицию указателя относительно начала файла в виде целого чис­ла. 
# Обратите внимание на то, что в Windows метод tell() считает символ \r как 
# допол­нительный байт, хотя этот символ удаляется при открытии файла в 
# текстовом режиме. Чтобы избежать этого несоответствия, следует открывать 
# файл в бинарном режиме, а не в текстовом

f.seek(смещение, позиция)
# устанавливает указатель в позицию, имеющую сме­щение 'cмещение' относительно 
# позиции 'позиция'. В параметре 'позиция' мoryr быть указаны следующие 
# атрибуты из модуля io или соответствующие им значения:
	io.SEEK_SET или 0
	# начало файла (значение по умолчанию)
	io.SEEK_CUR или 1
	# текущая позиция указателя. Положительное значение смещения вызывает 
	# перемещение к концу файла, отрицательное - к его началу
	io.SEEK_END или 2
	# конец файла

f.seekable()
# возвращает True, если указатель файла можно сдвинуть в друrую пози­цию, и 
# False - в противном случае



# atributes ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

name
# имя файла

mode
# режим, в котором был открыт файл

closed
# возвращает True, если файл был закрыт, и False - в противном случае.

encoding
# название кодировки, которая будет использоваться для преобразования строк 
# перед записью в файл или при чтении. Атрибут доступен только в текстовом 
# ре­жиме. Обратите также внимание на то, что изменить значение атрибута 
# нельзя, поскольку он доступен только для чтения.

buffer
# позволяет получить доступ к буферу. Атрибут доступен только в текстовом
# режиме. С помощью этого объекта можно записать последовательность байтов в 
# тексто­вый поток.
